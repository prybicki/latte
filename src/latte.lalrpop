use std::str::FromStr;
use crate::ast::*;

grammar;

// *** *** *** EXPESSIONS *** *** *** //

GIdent: String = {
    <s:r"[A-Za-z_'][A-Za-z0-9_']*"> => String::from(s),
}

GOperandOr: BinaryOp = {
    "||" => BinaryOp::Or,
}

GOperandAnd: BinaryOp = {
    "&&" => BinaryOp::And,
}

GOperandRel: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq,
}

GOperandAdd: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

GOperandMul: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

GInteger: i32 = {
    <v:r"[0-9]+"> =>? {
        match i32::from_str(v) {
            Err(_) => Err(lalrpop_util::ParseError::User{error: "oh no, invalid integer! ;C" }),
            Ok(v) => Ok(v),
        }
    }
}

GBoolean: bool = {
    "true" =>  true,
    "false" => false,
}

// TODO: bug here: printString("\\a\\n\n\tb\"");
// It won't be handled correctly because of naive removal of escape sequences.
GString: String = {
    <l:@L> <s:r#""([^"\\]|\\"|\\n|\\t|\\)*""#> <r:@R> => {
        s[1..s.len()-1]
        .replace(r#"\\"#, r#"\"#)
        .replace(r#"\n"#, "\n")
        .replace(r#"\t"#, "\t")
        .replace(r#"\""#, r#"""#)
    }
}

// Left Associative Expression Macro
LAExpMacro<Op, NextTier>: Box<ExpNode> = {
    <l:@L> <lexp:LAExpMacro<Op,NextTier>> <o:Op> <rexp:NextTier> <r:@R> => ExpNode::new_bin(l, r, o, lexp, rexp),
    NextTier,
};

// Right Associative Expression Macro
RAExpMacro<Op, NextTier>: Box<ExpNode> = {
    <l:@L> <lexp:NextTier> <o:Op> <rexp:RAExpMacro<Op,NextTier>> <r:@R> => ExpNode::new_bin(l, r, o, lexp, rexp),
    NextTier,
};

GList<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

GExp = GExpOr;
GExpOr  = RAExpMacro<GOperandOr,  GExpAnd>;
GExpAnd = RAExpMacro<GOperandAnd, GExpRel>;
GExpRel = LAExpMacro<GOperandRel, GExpAdd>;
GExpAdd = LAExpMacro<GOperandAdd, GExpMul>;
GExpMul = LAExpMacro<GOperandMul, GExpUnary>;

GExpUnary: Box<ExpNode> = {
    <l:@L> "!" <e:GExpAtom> <r:@R> => ExpNode::new_un(l, r, UnaryOp::Not, e),
    <l:@L> "-" <e:GExpAtom> <r:@R> => ExpNode::new_un(l, r, UnaryOp::Neg, e),
    <GExpAtom> => <>
}

GExpAtom: Box<ExpNode> = {
    <l:@L> <e:GInteger> <r:@R> => ExpNode::new(l, r, Exp::Int(e)),
    <l:@L> <e:GBoolean> <r:@R> => ExpNode::new(l, r, Exp::Bool(e)),
    <l:@L> <e:GString>  <r:@R> => ExpNode::new(l, r, Exp::Str(e)),
    <l:@L> <n:GIdent>   <r:@R> => ExpNode::new(l, r, Exp::Var(n)),
    <l:@L> <n:GIdent> "(" <a:GList<GExp, ",">> ")" <r:@R> => ExpNode::new(l, r, Exp::Call(n, a)),
    "(" <GExpOr> ")" => <>,
}

// *** TOP LEVEL ***

pub GProgram: Program = {
    <l:@L> <fs: GFnDef+> <r:@R> => Program{span: Span(l, r), functions: fs},
};

GType: TypeSpecifier = {
    <l:@L> "int" <r:@R>     => TypeSpecifier::new(l, r, Type::Int),
    <l:@L> "boolean" <r:@R> => TypeSpecifier::new(l, r, Type::Bool),
    <l:@L> "string" <r:@R>  => TypeSpecifier::new(l, r, Type::Str),
}

GVoid: TypeSpecifier = {
    <l:@L> "void" <r:@R>    => TypeSpecifier::new(l, r, Type::Void),
}

GTypeOrVoid: TypeSpecifier = {
    GType => <>,
    GVoid => <>
}

GParam: VarDecl = {
    <l:@L> <t:GType> <b:GDeclBodyNoInit> <r:@R> => VarDecl {span: Span(l, r), type_spec: t, vars: vec![b]},
};

GFnDef: FnDef = {
    <l:@L> <t:GTypeOrVoid> <n:GIdent> "(" <p:GList<GParam, ",">> ")" <b:GBlock> <r:@R> => {
        FnDef {span: Span(l, r), type_spec: t, ident: n, params: p, body: b}
    }
};

GDeclBodyNoInit: DeclBody = {
    <l:@L> <n:GIdent> <r:@R> => DeclBody {span: Span(l, r), ident: n, init: None},
}

GDeclBody: DeclBody = {
    <l:@L> <n:GIdent> <e:("=" <GExp>)?> <r:@R> => DeclBody {span: Span(l, r), ident: n, init: e},
}

GDecls: VarDecl = {
    <l:@L> <t:GType> <bs:GList<GDeclBody, ",">> <r:@R> => VarDecl {span: Span(l, r), type_spec: t, vars: bs},
};

GBlock: Box<StmtNode> = {
     <l:@L> "{" <s:GStmt*> "}" <r:@R> => StmtNode::new(l, r, Stmt::BStmt(s)),
}

// https://en.wikipedia.org/wiki/Dangling_else

GStmt: Box<StmtNode> = {
    <GOpenStmt>   => <>,
    <GClosedStmt> => <>,
}

GOpenStmt: Box<StmtNode> = {
    <l:@L> "if" "(" <c:GExp> ")" <t:GSimpleStmt> <r:@R>                          => StmtNode::new(l, r, Stmt::Cond(c,  t, None)),
    <l:@L> "if" "(" <c:GExp> ")" <t:GOpenStmt> <r:@R>                            => StmtNode::new(l, r, Stmt::Cond(c,  t, None)),
    <l:@L> "if" "(" <c:GExp> ")" <t:GClosedStmt> "else" <f:GOpenStmt> <r:@R>     => StmtNode::new(l, r, Stmt::Cond(c,  t, Some(f))),
    <l:@L> "while" "(" <c:GExp> ")" <t:GOpenStmt> <r:@R>                         => StmtNode::new(l, r, Stmt::While(c, t)),
}

GClosedStmt: Box<StmtNode> = {
    <l:@L> "if" "(" <c:GExp> ")" <t:GClosedStmt> "else" <f:GClosedStmt> <r:@R> => StmtNode::new(l, r, Stmt::Cond(c, t, Some(f))),
    <l:@L> "while" "(" <c:GExp> ")" <t:GClosedStmt> <r:@R>                     => StmtNode::new(l, r, Stmt::While(c, t)),
    <GSimpleStmt> => <>,
}

GSimpleStmt: Box<StmtNode> = {
    <GBlock>                                  => <>,
    <l:@L> ";" <r:@R>                         => StmtNode::new(l, r, Stmt::BStmt(vec![])),
    <l:@L> <e:GExp> ";" <r:@R>                => StmtNode::new(l, r, Stmt::EStmt(e)),
    <l:@L> <d:GDecls> ";" <r:@R>              => StmtNode::new(l, r, Stmt::Decl(d)),
    <l:@L> <n:GIdent> "=" <e:GExp> ";" <r:@R> => StmtNode::new(l, r, Stmt::Ass(n, e)),
    <l:@L> <n:GIdent> "++" ";" <r:@R>         => StmtNode::new(l, r, Stmt::Incr(n)),
    <l:@L> <n:GIdent> "--" ";" <r:@R>         => StmtNode::new(l, r, Stmt::Decr(n)),
    <l:@L> "return" <e:GExp> ";" <r:@R>       => StmtNode::new(l, r, Stmt::Ret(e)),
    <l:@L> "return" ";" <r:@R>                => StmtNode::new(l, r, Stmt::VRet),
}
