use std::str::FromStr;
use crate::ast::*;

// TODO make sure all panics at least print ERROR

grammar;

// *** EXPESSIONS ***

GIdent: String = {
    <s:r"[A-Za-z_'][A-Za-z0-9_']*"> => String::from(s),
}

GOperandOr: BinaryOp = {
    "||" => BinaryOp::Or,
}

GOperandAnd: BinaryOp = {
    "&&" => BinaryOp::And,
}

GOperandRel: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq,
}

GOperandAdd: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

GOperandMul: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

GInteger: Box<TypedExp> = {
    <s: r"[+-]"?> <v:r"[0-9]+"> => {
        // panic possible here
        let abs = i32::from_str(v).unwrap();
        let val = match s {
            Some("-") => -abs,
            _ => abs
        };
        Exp::new(Exp::Int(val))
    },
}

GBoolean: Box<TypedExp> = {
    "true" =>  Exp::new(Exp::Bool(true)),
    "false" => Exp::new(Exp::Bool(false)),
}

GString: Box<TypedExp> = {
    <s:r#""([^,",\\]|\\")*""#> => {
        let escaped = s[1..s.len()-1].replace(r#"\""#, r#"""#);
        Exp::new(Exp::Str(escaped))
    },
}

// Left Associative Expression Macro
LAExpMacro<Op, NextTier>: Box<TypedExp> = {
    LAExpMacro<Op,NextTier> Op NextTier => Exp::new(Exp::Binary(<>)),
    NextTier,
};

// Right Associative Expression Macro
RAExpMacro<Op, NextTier>: Box<TypedExp> = {
    NextTier Op RAExpMacro<Op,NextTier> => Exp::new(Exp::Binary(<>)),
    NextTier,
};

GList<T, Sep>: Vec<T> = { // (1)
    <v:(<T> Sep)*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

GExp = GExpOr;
GExpOr  = RAExpMacro<GOperandOr,  GExpAnd>;
GExpAnd = RAExpMacro<GOperandAnd, GExpRel>;
GExpRel = LAExpMacro<GOperandRel, GExpAdd>;
GExpAdd = LAExpMacro<GOperandAdd, GExpMul>;
GExpMul = LAExpMacro<GOperandMul, GExpUnary>;

GExpUnary: Box<TypedExp> = {
    "!" <e:GExpAtom> => Exp::new(Exp::Unary(UnaryOp::Not, e)),
    "-" <e:GExpAtom> => Exp::new(Exp::Unary(UnaryOp::Neg, e)),
    GExpAtom => <>,
}

GExpAtom: Box<TypedExp> = {
    GInteger => <>,
    GBoolean => <>,
    GString => <>,
    GIdent => Exp::new(Exp::Var(<>)),
    <GIdent> "(" <GList<GExp, ",">> ")" => Exp::new(Exp::Call(<>)),
    "(" <GExpOr> ")" => <>,
}

// *** TOP LEVEL ***

pub GProgram: Program = {
    <GFnDef+> => Program(<>)
};

GType: Type = {
    "int" => Type::Int,
    "boolean" => Type::Bool,
    "string" => Type::Str,
    "void" => Type::Void,
}

GArg: VarDecl = {
    <GType> <GIdent> => VarDecl(<>, Option::None),
};

GFnDef: FnDef = {
    <GType> <GIdent> "(" <GList<GArg, ",">> ")" <GBlock> => FnDef(<>),
};

GDeclBody: DeclBody = {
    <GIdent> <("=" <GExp>)?> => DeclBody(<>),
}

GDecl: Vec<VarDecl> = {
    <typename:GType> <v:GList<GDeclBody, ",">> => {
        let mut out = vec![];
        for body in v.into_iter() {
            let DeclBody(ident, maybe_exp) = body;
            out.push(VarDecl(typename, ident, maybe_exp))
        }
        out
    },
};

GBlock: Block = {
     "{" <GStmt*> "}" => Block(<>),
}

// https://en.wikipedia.org/wiki/Dangling_else

GStmt: Box<Stmt> = {
    <GOpenStmt>   => <>,
    <GClosedStmt> => <>,
}

GOpenStmt: Box<Stmt> = {
    "if" "(" <c:GExp> ")" <tstmt:GSimpleStmt>                          => Box::new(Stmt::Cond(c, Block(vec![tstmt]), Option::None)),
    "if" "(" <c:GExp> ")" <tstmt:GOpenStmt>                            => Box::new(Stmt::Cond(c, Block(vec![tstmt]), Option::None)),
    "if" "(" <c:GExp> ")" <tstmt:GClosedStmt> "else" <fstmt:GOpenStmt> => Box::new(Stmt::Cond(c, Block(vec![tstmt]), Option::Some(Block(vec![fstmt])))),
    "while" "(" <c:GExp> ")" <body:GOpenStmt>                          => Box::new(Stmt::While(c, Block(vec![body]))),
}

GClosedStmt: Box<Stmt> = {
    <GSimpleStmt>                                                        => <>,
    "if" "(" <c:GExp> ")" <tstmt:GClosedStmt> "else" <fstmt:GClosedStmt> => Box::new(Stmt::Cond(c, Block(vec![tstmt]), Option::Some(Block(vec![fstmt])))),
    "while" "(" <c:GExp> ")" <body:GClosedStmt>                          => Box::new(Stmt::While(c, Block(vec![body]))),
}

GSimpleStmt: Box<Stmt> = {
    ";"                      => Box::new(Stmt::BStmt(Block(vec![]))),
    <GExp> ";"               => Box::new(Stmt::EStmt(<>)),
    <GBlock>                 => Box::new(Stmt::BStmt(<>)),
    <GDecl> ";"              => Box::new(Stmt::Decl(<>)),
    <GIdent> "=" <GExp> ";"  => Box::new(Stmt::Ass(<>)),
    <GIdent> "++" ";"        => Box::new(Stmt::Incr(<>)),
    <GIdent> "--" ";"        => Box::new(Stmt::Decr(<>)),
    "return" <GExp> ";"      => Box::new(Stmt::Ret(<>)),
    "return" ";"             => Box::new(Stmt::VRet),
}


