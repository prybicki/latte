use std::str::FromStr;
use crate::ast::*;

// TODO make sure all panics at least print ERROR

grammar;

// *** *** *** EXPESSIONS *** *** *** //

GIdent: String = {
    <s:r"[A-Za-z_'][A-Za-z0-9_']*"> => String::from(s),
}

GOperandOr: BinaryOp = {
    "||" => BinaryOp::Or,
}

GOperandAnd: BinaryOp = {
    "&&" => BinaryOp::And,
}

GOperandRel: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq,
}

GOperandAdd: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

GOperandMul: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

GInteger: i32 = {
    <s: r"[+-]"?> <v:r"[0-9]+"> => {
        // panic possible here TODO handle
        let abs = i32::from_str(v).unwrap();
        match s {
            Some("-") => -abs,
            _ => abs
        }
    },
}

GBoolean: bool = {
    "true" =>  true,
    "false" => false,
}

GString: String = {
    <l:@L> <s:r#""([^,",\\]|\\")*""#> <r:@R> => s[1..s.len()-1].replace(r#"\""#, r#"""#),
}

// Left Associative Expression Macro
LAExpMacro<Op, NextTier>: Box<ExpNode> = {
    <l:@L> <lexp:LAExpMacro<Op,NextTier>> <o:Op> <rexp:NextTier> <r:@R> => ExpNode::new_bin(l, r, o, lexp, rexp),
    NextTier,
};

// Right Associative Expression Macro
RAExpMacro<Op, NextTier>: Box<ExpNode> = {
    <l:@L> <lexp:NextTier> <o:Op> <rexp:RAExpMacro<Op,NextTier>> <r:@R> => ExpNode::new_bin(l, r, o, lexp, rexp),
    NextTier,
};

GList<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

GExp = GExpOr;
GExpOr  = RAExpMacro<GOperandOr,  GExpAnd>;
GExpAnd = RAExpMacro<GOperandAnd, GExpRel>;
GExpRel = LAExpMacro<GOperandRel, GExpAdd>;
GExpAdd = LAExpMacro<GOperandAdd, GExpMul>;
GExpMul = LAExpMacro<GOperandMul, GExpUnary>;

GExpUnary: Box<ExpNode> = {
    <l:@L> "!" <e:GExpAtom> <r:@R> => ExpNode::new_un(l, r, UnaryOp::Not, e),
    <l:@L> "-" <e:GExpAtom> <r:@R> => ExpNode::new_un(l, r, UnaryOp::Neg, e),
    <GExpAtom> => <>
}

GExpAtom: Box<ExpNode> = {
    <l:@L> <e:GInteger> <r:@R> => ExpNode::new(l, r, Exp::Int(e)),
    <l:@L> <e:GBoolean> <r:@R> => ExpNode::new(l, r, Exp::Bool(e)),
    <l:@L> <e:GString>  <r:@R> => ExpNode::new(l, r, Exp::Str(e)),
    <l:@L> <n:GIdent>   <r:@R> => ExpNode::new(l, r, Exp::Var(n)),
    <l:@L> <n:GIdent> "(" <a:GList<GExp, ",">> ")" <r:@R> => ExpNode::new(l, r, Exp::Call(n, a)),
    "(" <GExpOr> ")" => <>,
}

// *** TOP LEVEL ***

pub GProgram: Program = {
    <l:@L> <fs: GFnDef+> <r:@R> => Program{span: Span(l, r), functions: fs},
};

GType: TypeSpecifier = {
    <l:@L> "int" <r:@R>     => TypeSpecifier::new(l, r, Type::Int),
    <l:@L> "boolean" <r:@R> => TypeSpecifier::new(l, r, Type::Bool),
    <l:@L> "string" <r:@R>  => TypeSpecifier::new(l, r, Type::Str),
    <l:@L> "void" <r:@R>    => TypeSpecifier::new(l, r, Type::Void),
}

GParam: VarDecl = {
    <l:@L> <t:GType> <b:GDeclBodyNoInit> <r:@R> => VarDecl {span: Span(l, r), type_spec: t, vars: vec![b]},
};

GFnDef: FnDef = {
    <l:@L> <t:GType> <n:GIdent> "(" <p:GList<GParam, ",">> ")" <b:GBlock> <r:@R> => {
        FnDef {span: Span(l, r), type_spec: t, ident: n, params: p, block: b}
    }
};

GDeclBodyNoInit: DeclBody = {
    <l:@L> <n:GIdent> <r:@R> => DeclBody {span: Span(l, r), ident: n, init: None},
}

GDeclBody: DeclBody = {
    <l:@L> <n:GIdent> <e:("=" <GExp>)?> <r:@R> => DeclBody {span: Span(l, r), ident: n, init: e},
}

GDecls: VarDecl = {
    <l:@L> <t:GType> <bs:GList<GDeclBody, ",">> <r:@R> => VarDecl {span: Span(l, r), type_spec: t, vars: bs},
};

GBlock: Block = {
     <l:@L> "{" <s:GStmt*> "}" <r:@R> => Block::new(l, r, s),
}

// https://en.wikipedia.org/wiki/Dangling_else

GStmt: Box<StmtNode> = {
    <GOpenStmt>   => <>,
    <GClosedStmt> => <>,
}

GOpenStmt: Box<StmtNode> = {
    <l:@L> "if" "(" <c:GExp> ")" <t:GSimpleStmt> <r:@R>                          => StmtNode::new(l, r, Stmt::Cond(c,   Block::new(t.span.0, t.span.1, vec![t]), None)),
    <l:@L> "if" "(" <c:GExp> ")" <t:GOpenStmt> <r:@R>                            => StmtNode::new(l, r, Stmt::Cond(c,   Block::new(t.span.0, t.span.1, vec![t]), None)),
    <l:@L> "if" "(" <c:GExp> ")" <t:GClosedStmt> "else" <f:GOpenStmt> <r:@R>     => StmtNode::new(l, r, Stmt::Cond(c,   Block::new(t.span.0, t.span.1, vec![t]), Some(Block::new(f.span.0, f.span.1, vec![f])))),
    <l:@L> "while" "(" <c:GExp> ")" <t:GOpenStmt> <r:@R>                         => StmtNode::new(l, r, Stmt::While(c,  Block::new(t.span.0, t.span.1, vec![t]))),
}

GClosedStmt: Box<StmtNode> = {
    <l:@L> "if" "(" <c:GExp> ")" <t:GClosedStmt> "else" <f:GClosedStmt> <r:@R> => StmtNode::new(l, r, Stmt::Cond(c,  Block::new(t.span.0, t.span.1, vec![t]), Some(Block::new(f.span.0, f.span.1, vec![f])))),
    <l:@L> "while" "(" <c:GExp> ")" <t:GClosedStmt> <r:@R>                     => StmtNode::new(l, r, Stmt::While(c, Block::new(t.span.0, t.span.1, vec![t]))),
    <GSimpleStmt> => <>,
}

GSimpleStmt: Box<StmtNode> = {
    <l:@L> ";" <r:@R>                         => StmtNode::new(l, r, Stmt::BStmt(Block::new(l, r, vec![]))),
    <l:@L> <e:GExp> ";" <r:@R>                => StmtNode::new(l, r, Stmt::EStmt(e)),
    <l:@L> <b:GBlock> <r:@R>                  => StmtNode::new(l, r, Stmt::BStmt(b)),
    <l:@L> <d:GDecls> ";" <r:@R>              => StmtNode::new(l, r, Stmt::Decl(d)),
    <l:@L> <n:GIdent> "=" <e:GExp> ";" <r:@R> => StmtNode::new(l, r, Stmt::Ass(n, e)),
    <l:@L> <n:GIdent> "++" ";" <r:@R>         => StmtNode::new(l, r, Stmt::Incr(n)),
    <l:@L> <n:GIdent> "--" ";" <r:@R>         => StmtNode::new(l, r, Stmt::Decr(n)),
    <l:@L> "return" <e:GExp> ";" <r:@R>       => StmtNode::new(l, r, Stmt::Ret(e)),
    <l:@L> "return" ";" <r:@R>                => StmtNode::new(l, r, Stmt::VRet),
}
