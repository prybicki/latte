use std::str::FromStr;
use crate::ast::*;

// TODO make sure all panics at least print ERROR

grammar;

// *** EXPRESSIONS ***

GIdent: String = {
    <s:r"([A-Z]|[a-z]|[_'])+"> => String::from(s),
}

GInteger: Box<Expr> = {
    <s: r"[+-]"?> <v:r"[0-9]+"> => {
        // panic possible here
        let abs = i32::from_str(v).unwrap();
        let val = match s {
            Some("-") => -abs,
            _ => abs
        };
        Box::new(Expr::Int(val))
    },
}

GBoolean: Box<Expr> = {
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false))
}

GString: Box<Expr> = {
    <s:r#""([^,",\\]|\\")*""#> => {
        let escaped = s[1..s.len()-1].replace(r#"\""#, r#"""#);
        Box::new(Expr::Str(escaped))
    },
}

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier,
};

GOperandOr: BinaryOp = {
    "||" => BinaryOp::Or,
}

GOperandAnd: BinaryOp = {
    "&&" => BinaryOp::And,
}

GOperandRel: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
}

GOperandAdd: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

GOperandMul: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

// Left Associative Expression Macro
LAExprMacro<Op, NextTier>: Box<Expr> = {
    LAExprMacro<Op,NextTier> Op NextTier => Box::new(Expr::Binary(<>)),
    NextTier,
};

// Right Associative Expression Macro
RAExprMacro<Op, NextTier>: Box<Expr> = {
    NextTier Op RAExprMacro<Op,NextTier> => Box::new(Expr::Binary(<>)),
    NextTier,
};

GList<T, Sep>: Vec<T> = { // (1)
    <v:(<T> Sep)*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

GExpr = GExprOr;
GExprOr  = RAExprMacro<GOperandOr, GExprAnd>;
GExprAnd = RAExprMacro<GOperandAnd, GExprRel>;
GExprRel = LAExprMacro<GOperandRel, GExprAdd>;
GExprAdd = LAExprMacro<GOperandAdd, GExprMul>;
GExprMul = LAExprMacro<GOperandMul, GExprUnary>;

GExprUnary: Box<Expr> = {
    "!" <e:GExprAtom> => Box::new(Expr::Unary(UnaryOp::Not, e)),
    "-" <e:GExprAtom> => Box::new(Expr::Unary(UnaryOp::Neg, e)),
    GExprAtom => <>,
}

GExprAtom: Box<Expr> = {
    GInteger => <>,
    GBoolean => <>,
    GString => <>,
    GIdent => Box::new(Expr::Var(<>)),
    <GIdent> "(" <GList<GExpr, ",">> ")" => Box::new(Expr::Call(<>)),
    "(" <GExprOr> ")" => <>,
}

// *** TOP LEVEL ***

pub GProgram: Program = {
    GList<GTopDef, ""> => Program(<>),
};

GType: Type = {
    "int" => Type::Int,
    "bool" => Type::Bool,
    "string" => Type::Str,
    "void" => Type::Void,
}

GArg: VarDecl = {
    <GType> <GIdent> => VarDecl(<>, Option::None),
};

GTopDef: TopDef = {
    <GType> <GIdent> "(" <GList<GArg, ",">> ")" <GBlock> => TopDef::FnDef(<>),
};

// Semicolon is an integral part of statement, hence empty list separator.
GBlock: Block = {
     "{" <GList<GStmt, "">> "}" => Block(<>),
}

//     <v:(<T> Sep)*> <e:T?> => match e { // (2)

GDeclBody: DeclBody = {
    <GIdent> <("=" <GExpr>)?> => DeclBody(<>),
}

GDecl: Vec<VarDecl> = {
    <typename:GType> <v:GList<GDeclBody, ",">> => {
        let out = vec![];
        for body in v.iter() {
            let (ident, maybe_expr) = body;
            out.push(VarDecl(typename, ident, maybe_expr))
        }
    },
};

GStmt: Stmt = {
    ";" => Stmt::BStmt(vec![]),
    <GExpr> ";" => Stmt::EStmt(<>),
    <GBlock> => Stmt::BStmt(<>),
    <GDecl> ";" => Stmt::Decl(<>),
    <GIdent> "=" <GExpr> ";" => Stmt::Ass(<>),
    <GIdent> "++" ";" => Stmt::Incr(<>),
    <GIdent> "--" ";" => Stmt::Decr(<>),
    "return" <GExpr> ";" => Stmt::Ret(<>),
    "return" ";" => Stmt::VRet,
    "if" "(" <GExpr> ")" <GStmt> <("else" <GStmt>)?> => Stmt::Cond(<>),
    "while" "(" <GExpr> ")" <GStmt> => Stmt::While(<>),
}

// Remove IF ambiguity
// https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers

