use std::str::FromStr;
use crate::ast::*;

// TODO make sure all panics at least print ERROR

grammar;

// *** EXPRESSIONS ***

GIdent: String = {
    <s:r"[A-Za-z_'][A-Za-z0-9_']*"> => String::from(s),
}

GInteger: Box<Expr> = {
    <s: r"[+-]"?> <v:r"[0-9]+"> => {
        // panic possible here
        let abs = i32::from_str(v).unwrap();
        let val = match s {
            Some("-") => -abs,
            _ => abs
        };
        Box::new(Expr::Int(val))
    },
}

GBoolean: Box<Expr> = {
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false))
}

GString: Box<Expr> = {
    <s:r#""([^,",\\]|\\")*""#> => {
        let escaped = s[1..s.len()-1].replace(r#"\""#, r#"""#);
        Box::new(Expr::Str(escaped))
    },
}

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier,
};

GOperandOr: BinaryOp = {
    "||" => BinaryOp::Or,
}

GOperandAnd: BinaryOp = {
    "&&" => BinaryOp::And,
}

GOperandRel: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq,
}

GOperandAdd: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

GOperandMul: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

// Left Associative Expression Macro
LAExprMacro<Op, NextTier>: Box<Expr> = {
    LAExprMacro<Op,NextTier> Op NextTier => Box::new(Expr::Binary(<>)),
    NextTier,
};

// Right Associative Expression Macro
RAExprMacro<Op, NextTier>: Box<Expr> = {
    NextTier Op RAExprMacro<Op,NextTier> => Box::new(Expr::Binary(<>)),
    NextTier,
};

GList<T, Sep>: Vec<T> = { // (1)
    <v:(<T> Sep)*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

GExpr = GExprOr;
GExprOr  = RAExprMacro<GOperandOr, GExprAnd>;
GExprAnd = RAExprMacro<GOperandAnd, GExprRel>;
GExprRel = LAExprMacro<GOperandRel, GExprAdd>;
GExprAdd = LAExprMacro<GOperandAdd, GExprMul>;
GExprMul = LAExprMacro<GOperandMul, GExprUnary>;

GExprUnary: Box<Expr> = {
    "!" <e:GExprAtom> => Box::new(Expr::Unary(UnaryOp::Not, e)),
    "-" <e:GExprAtom> => Box::new(Expr::Unary(UnaryOp::Neg, e)),
    GExprAtom => <>,
}

GExprAtom: Box<Expr> = {
    GInteger => <>,
    GBoolean => <>,
    GString => <>,
    GIdent => Box::new(Expr::Var(<>)),
    <GIdent> "(" <GList<GExpr, ",">> ")" => Box::new(Expr::Call(<>)),
    "(" <GExprOr> ")" => <>,
}

// *** TOP LEVEL ***

pub GProgram: Program = {
    <GTopDef+> => Program(<>)
};

GType: Type = {
    "int" => Type::Int,
    "boolean" => Type::Bool,
    "string" => Type::Str,
    "void" => Type::Void,
}

GArg: VarDecl = {
    <GType> <GIdent> => VarDecl(<>, Option::None),
};

GTopDef: TopDef = {
    <GType> <GIdent> "(" <GList<GArg, ",">> ")" <GBlock> => TopDef::FnDef(<>),
};


GDeclBody: DeclBody = {
    <GIdent> <("=" <GExpr>)?> => DeclBody(<>),
}

GDecl: Vec<VarDecl> = {
    <typename:GType> <v:GList<GDeclBody, ",">> => {
        let mut out = vec![];
        for body in v.into_iter() {
            let DeclBody(ident, maybe_expr) = body;
            out.push(VarDecl(typename, ident, maybe_expr))
        }
        out
    },
};

// Semicolon is an integral part of statement, hence empty list separator.
GBlock: Block = {
     "{" <GStmt*> "}" => Block(<>),
}

// https://en.wikipedia.org/wiki/Dangling_else

GStmt: Box<Stmt> = {
    <GOpenStmt>   => <>,
    <GClosedStmt> => <>,
}

GOpenStmt: Box<Stmt> = {
    "if" "(" <c:GExpr> ")" <t:GSimpleStmt>                      => Box::new(Stmt::Cond(c, t, Option::None)),
    "if" "(" <c:GExpr> ")" <t:GOpenStmt>                        => Box::new(Stmt::Cond(c, t, Option::None)),
    "if" "(" <c:GExpr> ")" <t:GClosedStmt> "else" <f:GOpenStmt> => Box::new(Stmt::Cond(c, t, Option::Some(f))),
    "while" "(" <c:GExpr> ")" <body:GOpenStmt>                  => Box::new(Stmt::While(c, body)),
}

GClosedStmt: Box<Stmt> = {
    <GSimpleStmt>                                                 => <>,
    "if" "(" <c:GExpr> ")" <t:GClosedStmt> "else" <f:GClosedStmt> => Box::new(Stmt::Cond(c, t, Option::Some(f))),
    "while" "(" <c:GExpr> ")" <body:GClosedStmt>                  => Box::new(Stmt::While(c, body)),
}

GSimpleStmt: Box<Stmt> = {
    ";"                      => Box::new(Stmt::BStmt(Block(vec![]))),
    <GExpr> ";"              => Box::new(Stmt::EStmt(<>)),
    <GBlock>                 => Box::new(Stmt::BStmt(<>)),
    <GDecl> ";"              => Box::new(Stmt::Decl(<>)),
    <GIdent> "=" <GExpr> ";" => Box::new(Stmt::Ass(<>)),
    <GIdent> "++" ";"        => Box::new(Stmt::Incr(<>)),
    <GIdent> "--" ";"        => Box::new(Stmt::Decr(<>)),
    "return" <GExpr> ";"     => Box::new(Stmt::Ret(<>)),
    "return" ";"             => Box::new(Stmt::VRet),
}


