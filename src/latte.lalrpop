use std::str::FromStr;
use crate::ast::*;

// TODO make sure all panics at least print ERROR

grammar;

GIdent: String = {
    <s:r"([A-Z]|[a-z]|[_'])+"> => String::from(s),
}

pub GInteger: Box<Expr> = {
    <s: r"[+-]"?> <v:r"[0-9]+"> => {
        // panic possible here
        let abs = i32::from_str(v).unwrap();
        let val = match s {
            Some("-") => -abs,
            _ => abs
        };
        Box::new(Expr::Int(val))
    },
}

pub GBoolean: Box<Expr> = {
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false))
}

pub GString: Box<Expr> = {
    <s:r#""([^,",\\]|\\")*""#> => {
        let escaped = s[1..s.len()-1].replace(r#"\""#, r#"""#);
        Box::new(Expr::Str(escaped))
    },
}

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier,
};

GOperandOr: BinaryOp = {
    "||" => BinaryOp::Or,
}

GOperandAnd: BinaryOp = {
    "&&" => BinaryOp::And,
}

GOperandRel: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Lte,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Gte,
}

GOperandAdd: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

GOperandMul: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

// Left Associative Expression Macro
LAExprMacro<Op, NextTier>: Box<Expr> = {
    LAExprMacro<Op,NextTier> Op NextTier => Box::new(Expr::Binary(<>)),
    NextTier,
};

// Right Associative Expression Macro
RAExprMacro<Op, NextTier>: Box<Expr> = {
    NextTier Op RAExprMacro<Op,NextTier> => Box::new(Expr::Binary(<>)),
    NextTier,
};

CommaSeparatedList<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub GExpr = GExprOr;

GExprOr  = RAExprMacro<GOperandOr, GExprAnd>;
GExprAnd = RAExprMacro<GOperandAnd, GExprRel>;
GExprRel = LAExprMacro<GOperandRel, GExprAdd>;
GExprAdd = LAExprMacro<GOperandAdd, GExprMul>;
GExprMul = LAExprMacro<GOperandMul, GExprUnary>;

GExprUnary: Box<Expr> = {
    "!" <e:GExprAtom> => Box::new(Expr::Unary(UnaryOp::Not, e)),
    "-" <e:GExprAtom> => Box::new(Expr::Unary(UnaryOp::Neg, e)),
    GExprAtom => <>,
}

GExprAtom: Box<Expr> = {
    GInteger => <>,
    GBoolean => <>,
    GString => <>,
    <GIdent> "(" <CommaSeparatedList<GExpr>> ")" => Box::new(Expr::Call(<>)),
    GIdent => Box::new(Expr::Var(<>)),
    "(" <GExprOr> ")" => <>,
}

// function call


// TODO finish rest of expression, maybe change AST

// https://www.mimuw.edu.pl/~ben/Zajecia/Mrj2018/Latte/
// GExprAdd...






//
//GOp1: Op = {
//    "+" => Op::Add,
//    "-" => Op::Sub,
//};
//
//GOp2: Op = {
//    "*" => Op::Mul,
//    "/" => Op::Div,
//};
//
//GExp1: Box<Exp> = {
//    <l:GExp2> "+" <r:GExp1> => Box::new(Exp::Exp(l, Op::Add, r)),
//    <GExp2>,
//}
//
//GExp2: Box<Exp> = {
//    <l:GExp2> "-" <r:GExp3> => Box::new(Exp::Exp(l, Op::Sub, r)),
//    GExp3,
//}
//
//GExp3: Box<Exp> = {
//    <GExp3> <GOp2> <GTerm> => Box::new(Exp::Exp(<>)),
//    <GTerm>,
//}
//
//GTerm: Box<Exp> = {
//    GInteger => Box::new(Exp::Lit(<>)),
//    GIdent => Box::new(Exp::Var(<>)),
//    "(" <GExp1> ")",
//};
//
//GStmt: Box<Stmt> = {
//    <GIdent> "=" <GExp1> => Box::new(Stmt::Assignment(<>)),
//    <GExp1> => Box::new(Stmt::Print(<>)),
//}
//
//pub GProgram: Program = {
//    <v:(<GStmt> ";")*> <e:GStmt?> => match e {
//        None => Program(v),
//        Some(e) => Program({let mut v = v; v.push(e); v}),
//    },
//}
